// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: pirmessage.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_pirmessage_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_pirmessage_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4023000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4023004 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_pirmessage_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_pirmessage_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable
    descriptor_table_pirmessage_2eproto;
namespace pir_message {
class DBInfo;
struct DBInfoDefaultTypeInternal;
extern DBInfoDefaultTypeInternal _DBInfo_default_instance_;
class DBInfoRequest;
struct DBInfoRequestDefaultTypeInternal;
extern DBInfoRequestDefaultTypeInternal _DBInfoRequest_default_instance_;
class EmptyParam;
struct EmptyParamDefaultTypeInternal;
extern EmptyParamDefaultTypeInternal _EmptyParam_default_instance_;
class PirParam_Config_messsage;
struct PirParam_Config_messsageDefaultTypeInternal;
extern PirParam_Config_messsageDefaultTypeInternal _PirParam_Config_messsage_default_instance_;
class RequestData;
struct RequestDataDefaultTypeInternal;
extern RequestDataDefaultTypeInternal _RequestData_default_instance_;
class ResponseData;
struct ResponseDataDefaultTypeInternal;
extern ResponseDataDefaultTypeInternal _ResponseData_default_instance_;
}  // namespace pir_message
PROTOBUF_NAMESPACE_OPEN
template <>
::pir_message::DBInfo* Arena::CreateMaybeMessage<::pir_message::DBInfo>(Arena*);
template <>
::pir_message::DBInfoRequest* Arena::CreateMaybeMessage<::pir_message::DBInfoRequest>(Arena*);
template <>
::pir_message::EmptyParam* Arena::CreateMaybeMessage<::pir_message::EmptyParam>(Arena*);
template <>
::pir_message::PirParam_Config_messsage* Arena::CreateMaybeMessage<::pir_message::PirParam_Config_messsage>(Arena*);
template <>
::pir_message::RequestData* Arena::CreateMaybeMessage<::pir_message::RequestData>(Arena*);
template <>
::pir_message::ResponseData* Arena::CreateMaybeMessage<::pir_message::ResponseData>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

namespace pir_message {

// ===================================================================


// -------------------------------------------------------------------

class EmptyParam final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:pir_message.EmptyParam) */ {
 public:
  inline EmptyParam() : EmptyParam(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EmptyParam(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EmptyParam(const EmptyParam& from);
  EmptyParam(EmptyParam&& from) noexcept
    : EmptyParam() {
    *this = ::std::move(from);
  }

  inline EmptyParam& operator=(const EmptyParam& from) {
    CopyFrom(from);
    return *this;
  }
  inline EmptyParam& operator=(EmptyParam&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EmptyParam& default_instance() {
    return *internal_default_instance();
  }
  static inline const EmptyParam* internal_default_instance() {
    return reinterpret_cast<const EmptyParam*>(
               &_EmptyParam_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(EmptyParam& a, EmptyParam& b) {
    a.Swap(&b);
  }
  inline void Swap(EmptyParam* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EmptyParam* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EmptyParam* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EmptyParam>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const EmptyParam& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const EmptyParam& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "pir_message.EmptyParam";
  }
  protected:
  explicit EmptyParam(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:pir_message.EmptyParam)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_pirmessage_2eproto;
};// -------------------------------------------------------------------

class DBInfoRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pir_message.DBInfoRequest) */ {
 public:
  inline DBInfoRequest() : DBInfoRequest(nullptr) {}
  ~DBInfoRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DBInfoRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DBInfoRequest(const DBInfoRequest& from);
  DBInfoRequest(DBInfoRequest&& from) noexcept
    : DBInfoRequest() {
    *this = ::std::move(from);
  }

  inline DBInfoRequest& operator=(const DBInfoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DBInfoRequest& operator=(DBInfoRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DBInfoRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DBInfoRequest* internal_default_instance() {
    return reinterpret_cast<const DBInfoRequest*>(
               &_DBInfoRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(DBInfoRequest& a, DBInfoRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DBInfoRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DBInfoRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DBInfoRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DBInfoRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DBInfoRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DBInfoRequest& from) {
    DBInfoRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DBInfoRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "pir_message.DBInfoRequest";
  }
  protected:
  explicit DBInfoRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDBNameFieldNumber = 1,
  };
  // string DBName = 1;
  void clear_dbname() ;
  const std::string& dbname() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_dbname(Arg_&& arg, Args_... args);
  std::string* mutable_dbname();
  PROTOBUF_NODISCARD std::string* release_dbname();
  void set_allocated_dbname(std::string* ptr);

  private:
  const std::string& _internal_dbname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dbname(
      const std::string& value);
  std::string* _internal_mutable_dbname();

  public:
  // @@protoc_insertion_point(class_scope:pir_message.DBInfoRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dbname_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pirmessage_2eproto;
};// -------------------------------------------------------------------

class DBInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pir_message.DBInfo) */ {
 public:
  inline DBInfo() : DBInfo(nullptr) {}
  ~DBInfo() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DBInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DBInfo(const DBInfo& from);
  DBInfo(DBInfo&& from) noexcept
    : DBInfo() {
    *this = ::std::move(from);
  }

  inline DBInfo& operator=(const DBInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline DBInfo& operator=(DBInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DBInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const DBInfo* internal_default_instance() {
    return reinterpret_cast<const DBInfo*>(
               &_DBInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(DBInfo& a, DBInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(DBInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DBInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DBInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DBInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DBInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DBInfo& from) {
    DBInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DBInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "pir_message.DBInfo";
  }
  protected:
  explicit DBInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNumOfItemsFieldNumber = 1,
    kSizePerItemFieldNumber = 2,
  };
  // uint64 Num_of_items = 1;
  void clear_num_of_items() ;
  ::uint64_t num_of_items() const;
  void set_num_of_items(::uint64_t value);

  private:
  ::uint64_t _internal_num_of_items() const;
  void _internal_set_num_of_items(::uint64_t value);

  public:
  // uint64 Size_per_item = 2;
  void clear_size_per_item() ;
  ::uint64_t size_per_item() const;
  void set_size_per_item(::uint64_t value);

  private:
  ::uint64_t _internal_size_per_item() const;
  void _internal_set_size_per_item(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:pir_message.DBInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::uint64_t num_of_items_;
    ::uint64_t size_per_item_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pirmessage_2eproto;
};// -------------------------------------------------------------------

class PirParam_Config_messsage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pir_message.PirParam_Config_messsage) */ {
 public:
  inline PirParam_Config_messsage() : PirParam_Config_messsage(nullptr) {}
  ~PirParam_Config_messsage() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PirParam_Config_messsage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PirParam_Config_messsage(const PirParam_Config_messsage& from);
  PirParam_Config_messsage(PirParam_Config_messsage&& from) noexcept
    : PirParam_Config_messsage() {
    *this = ::std::move(from);
  }

  inline PirParam_Config_messsage& operator=(const PirParam_Config_messsage& from) {
    CopyFrom(from);
    return *this;
  }
  inline PirParam_Config_messsage& operator=(PirParam_Config_messsage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PirParam_Config_messsage& default_instance() {
    return *internal_default_instance();
  }
  static inline const PirParam_Config_messsage* internal_default_instance() {
    return reinterpret_cast<const PirParam_Config_messsage*>(
               &_PirParam_Config_messsage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(PirParam_Config_messsage& a, PirParam_Config_messsage& b) {
    a.Swap(&b);
  }
  inline void Swap(PirParam_Config_messsage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PirParam_Config_messsage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PirParam_Config_messsage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PirParam_Config_messsage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PirParam_Config_messsage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PirParam_Config_messsage& from) {
    PirParam_Config_messsage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PirParam_Config_messsage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "pir_message.PirParam_Config_messsage";
  }
  protected:
  explicit PirParam_Config_messsage(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEPParamsFieldNumber = 7,
    kUseSymmetricFieldNumber = 1,
    kUseBatchingFieldNumber = 2,
    kUseRecursiveModSwitchingFieldNumber = 3,
    kDFieldNumber = 6,
    kNumOfItemsFieldNumber = 4,
    kSizePerItemFieldNumber = 5,
  };
  // bytes EPParams = 7;
  void clear_epparams() ;
  const std::string& epparams() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_epparams(Arg_&& arg, Args_... args);
  std::string* mutable_epparams();
  PROTOBUF_NODISCARD std::string* release_epparams();
  void set_allocated_epparams(std::string* ptr);

  private:
  const std::string& _internal_epparams() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_epparams(
      const std::string& value);
  std::string* _internal_mutable_epparams();

  public:
  // bool Use_symmetric = 1;
  void clear_use_symmetric() ;
  bool use_symmetric() const;
  void set_use_symmetric(bool value);

  private:
  bool _internal_use_symmetric() const;
  void _internal_set_use_symmetric(bool value);

  public:
  // bool Use_batching = 2;
  void clear_use_batching() ;
  bool use_batching() const;
  void set_use_batching(bool value);

  private:
  bool _internal_use_batching() const;
  void _internal_set_use_batching(bool value);

  public:
  // bool Use_recursive_mod_switching = 3;
  void clear_use_recursive_mod_switching() ;
  bool use_recursive_mod_switching() const;
  void set_use_recursive_mod_switching(bool value);

  private:
  bool _internal_use_recursive_mod_switching() const;
  void _internal_set_use_recursive_mod_switching(bool value);

  public:
  // uint32 D = 6;
  void clear_d() ;
  ::uint32_t d() const;
  void set_d(::uint32_t value);

  private:
  ::uint32_t _internal_d() const;
  void _internal_set_d(::uint32_t value);

  public:
  // uint64 Num_of_items = 4;
  void clear_num_of_items() ;
  ::uint64_t num_of_items() const;
  void set_num_of_items(::uint64_t value);

  private:
  ::uint64_t _internal_num_of_items() const;
  void _internal_set_num_of_items(::uint64_t value);

  public:
  // uint64 Size_per_item = 5;
  void clear_size_per_item() ;
  ::uint64_t size_per_item() const;
  void set_size_per_item(::uint64_t value);

  private:
  ::uint64_t _internal_size_per_item() const;
  void _internal_set_size_per_item(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:pir_message.PirParam_Config_messsage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr epparams_;
    bool use_symmetric_;
    bool use_batching_;
    bool use_recursive_mod_switching_;
    ::uint32_t d_;
    ::uint64_t num_of_items_;
    ::uint64_t size_per_item_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pirmessage_2eproto;
};// -------------------------------------------------------------------

class RequestData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pir_message.RequestData) */ {
 public:
  inline RequestData() : RequestData(nullptr) {}
  ~RequestData() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RequestData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestData(const RequestData& from);
  RequestData(RequestData&& from) noexcept
    : RequestData() {
    *this = ::std::move(from);
  }

  inline RequestData& operator=(const RequestData& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestData& operator=(RequestData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestData& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestData* internal_default_instance() {
    return reinterpret_cast<const RequestData*>(
               &_RequestData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(RequestData& a, RequestData& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestData* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RequestData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RequestData& from) {
    RequestData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "pir_message.RequestData";
  }
  protected:
  explicit RequestData(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGkeyFieldNumber = 4,
    kQueryFieldNumber = 5,
    kDBNameFieldNumber = 6,
    kPirConfigFieldNumber = 3,
    kRequestIdFieldNumber = 1,
    kClientIdFieldNumber = 2,
  };
  // bytes Gkey = 4;
  void clear_gkey() ;
  const std::string& gkey() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_gkey(Arg_&& arg, Args_... args);
  std::string* mutable_gkey();
  PROTOBUF_NODISCARD std::string* release_gkey();
  void set_allocated_gkey(std::string* ptr);

  private:
  const std::string& _internal_gkey() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_gkey(
      const std::string& value);
  std::string* _internal_mutable_gkey();

  public:
  // bytes Query = 5;
  void clear_query() ;
  const std::string& query() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_query(Arg_&& arg, Args_... args);
  std::string* mutable_query();
  PROTOBUF_NODISCARD std::string* release_query();
  void set_allocated_query(std::string* ptr);

  private:
  const std::string& _internal_query() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_query(
      const std::string& value);
  std::string* _internal_mutable_query();

  public:
  // string DBName = 6;
  void clear_dbname() ;
  const std::string& dbname() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_dbname(Arg_&& arg, Args_... args);
  std::string* mutable_dbname();
  PROTOBUF_NODISCARD std::string* release_dbname();
  void set_allocated_dbname(std::string* ptr);

  private:
  const std::string& _internal_dbname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dbname(
      const std::string& value);
  std::string* _internal_mutable_dbname();

  public:
  // .pir_message.PirParam_Config_messsage PirConfig = 3;
  bool has_pirconfig() const;
  void clear_pirconfig() ;
  const ::pir_message::PirParam_Config_messsage& pirconfig() const;
  PROTOBUF_NODISCARD ::pir_message::PirParam_Config_messsage* release_pirconfig();
  ::pir_message::PirParam_Config_messsage* mutable_pirconfig();
  void set_allocated_pirconfig(::pir_message::PirParam_Config_messsage* pirconfig);
  private:
  const ::pir_message::PirParam_Config_messsage& _internal_pirconfig() const;
  ::pir_message::PirParam_Config_messsage* _internal_mutable_pirconfig();
  public:
  void unsafe_arena_set_allocated_pirconfig(
      ::pir_message::PirParam_Config_messsage* pirconfig);
  ::pir_message::PirParam_Config_messsage* unsafe_arena_release_pirconfig();
  // uint32 RequestId = 1;
  void clear_requestid() ;
  ::uint32_t requestid() const;
  void set_requestid(::uint32_t value);

  private:
  ::uint32_t _internal_requestid() const;
  void _internal_set_requestid(::uint32_t value);

  public:
  // uint32 ClientId = 2;
  void clear_clientid() ;
  ::uint32_t clientid() const;
  void set_clientid(::uint32_t value);

  private:
  ::uint32_t _internal_clientid() const;
  void _internal_set_clientid(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:pir_message.RequestData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr gkey_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr query_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dbname_;
    ::pir_message::PirParam_Config_messsage* pirconfig_;
    ::uint32_t requestid_;
    ::uint32_t clientid_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pirmessage_2eproto;
};// -------------------------------------------------------------------

class ResponseData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pir_message.ResponseData) */ {
 public:
  inline ResponseData() : ResponseData(nullptr) {}
  ~ResponseData() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ResponseData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResponseData(const ResponseData& from);
  ResponseData(ResponseData&& from) noexcept
    : ResponseData() {
    *this = ::std::move(from);
  }

  inline ResponseData& operator=(const ResponseData& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResponseData& operator=(ResponseData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResponseData& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResponseData* internal_default_instance() {
    return reinterpret_cast<const ResponseData*>(
               &_ResponseData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ResponseData& a, ResponseData& b) {
    a.Swap(&b);
  }
  inline void Swap(ResponseData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResponseData* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResponseData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResponseData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResponseData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ResponseData& from) {
    ResponseData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "pir_message.ResponseData";
  }
  protected:
  explicit ResponseData(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 3,
    kDataFieldNumber = 4,
    kRequestIdFieldNumber = 1,
    kResultFieldNumber = 2,
  };
  // string Msg = 3;
  void clear_msg() ;
  const std::string& msg() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_msg(Arg_&& arg, Args_... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* ptr);

  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(
      const std::string& value);
  std::string* _internal_mutable_msg();

  public:
  // bytes Data = 4;
  void clear_data() ;
  const std::string& data() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_data(Arg_&& arg, Args_... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* ptr);

  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(
      const std::string& value);
  std::string* _internal_mutable_data();

  public:
  // uint32 RequestId = 1;
  void clear_requestid() ;
  ::uint32_t requestid() const;
  void set_requestid(::uint32_t value);

  private:
  ::uint32_t _internal_requestid() const;
  void _internal_set_requestid(::uint32_t value);

  public:
  // int32 Result = 2;
  void clear_result() ;
  ::int32_t result() const;
  void set_result(::int32_t value);

  private:
  ::int32_t _internal_result() const;
  void _internal_set_result(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:pir_message.ResponseData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    ::uint32_t requestid_;
    ::int32_t result_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pirmessage_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// EmptyParam

// -------------------------------------------------------------------

// DBInfoRequest

// string DBName = 1;
inline void DBInfoRequest::clear_dbname() {
  _impl_.dbname_.ClearToEmpty();
}
inline const std::string& DBInfoRequest::dbname() const {
  // @@protoc_insertion_point(field_get:pir_message.DBInfoRequest.DBName)
  return _internal_dbname();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DBInfoRequest::set_dbname(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.dbname_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pir_message.DBInfoRequest.DBName)
}
inline std::string* DBInfoRequest::mutable_dbname() {
  std::string* _s = _internal_mutable_dbname();
  // @@protoc_insertion_point(field_mutable:pir_message.DBInfoRequest.DBName)
  return _s;
}
inline const std::string& DBInfoRequest::_internal_dbname() const {
  return _impl_.dbname_.Get();
}
inline void DBInfoRequest::_internal_set_dbname(const std::string& value) {
  ;


  _impl_.dbname_.Set(value, GetArenaForAllocation());
}
inline std::string* DBInfoRequest::_internal_mutable_dbname() {
  ;
  return _impl_.dbname_.Mutable( GetArenaForAllocation());
}
inline std::string* DBInfoRequest::release_dbname() {
  // @@protoc_insertion_point(field_release:pir_message.DBInfoRequest.DBName)
  return _impl_.dbname_.Release();
}
inline void DBInfoRequest::set_allocated_dbname(std::string* value) {
  _impl_.dbname_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.dbname_.IsDefault()) {
          _impl_.dbname_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pir_message.DBInfoRequest.DBName)
}

// -------------------------------------------------------------------

// DBInfo

// uint64 Num_of_items = 1;
inline void DBInfo::clear_num_of_items() {
  _impl_.num_of_items_ = ::uint64_t{0u};
}
inline ::uint64_t DBInfo::num_of_items() const {
  // @@protoc_insertion_point(field_get:pir_message.DBInfo.Num_of_items)
  return _internal_num_of_items();
}
inline void DBInfo::set_num_of_items(::uint64_t value) {
  _internal_set_num_of_items(value);
  // @@protoc_insertion_point(field_set:pir_message.DBInfo.Num_of_items)
}
inline ::uint64_t DBInfo::_internal_num_of_items() const {
  return _impl_.num_of_items_;
}
inline void DBInfo::_internal_set_num_of_items(::uint64_t value) {
  ;
  _impl_.num_of_items_ = value;
}

// uint64 Size_per_item = 2;
inline void DBInfo::clear_size_per_item() {
  _impl_.size_per_item_ = ::uint64_t{0u};
}
inline ::uint64_t DBInfo::size_per_item() const {
  // @@protoc_insertion_point(field_get:pir_message.DBInfo.Size_per_item)
  return _internal_size_per_item();
}
inline void DBInfo::set_size_per_item(::uint64_t value) {
  _internal_set_size_per_item(value);
  // @@protoc_insertion_point(field_set:pir_message.DBInfo.Size_per_item)
}
inline ::uint64_t DBInfo::_internal_size_per_item() const {
  return _impl_.size_per_item_;
}
inline void DBInfo::_internal_set_size_per_item(::uint64_t value) {
  ;
  _impl_.size_per_item_ = value;
}

// -------------------------------------------------------------------

// PirParam_Config_messsage

// bool Use_symmetric = 1;
inline void PirParam_Config_messsage::clear_use_symmetric() {
  _impl_.use_symmetric_ = false;
}
inline bool PirParam_Config_messsage::use_symmetric() const {
  // @@protoc_insertion_point(field_get:pir_message.PirParam_Config_messsage.Use_symmetric)
  return _internal_use_symmetric();
}
inline void PirParam_Config_messsage::set_use_symmetric(bool value) {
  _internal_set_use_symmetric(value);
  // @@protoc_insertion_point(field_set:pir_message.PirParam_Config_messsage.Use_symmetric)
}
inline bool PirParam_Config_messsage::_internal_use_symmetric() const {
  return _impl_.use_symmetric_;
}
inline void PirParam_Config_messsage::_internal_set_use_symmetric(bool value) {
  ;
  _impl_.use_symmetric_ = value;
}

// bool Use_batching = 2;
inline void PirParam_Config_messsage::clear_use_batching() {
  _impl_.use_batching_ = false;
}
inline bool PirParam_Config_messsage::use_batching() const {
  // @@protoc_insertion_point(field_get:pir_message.PirParam_Config_messsage.Use_batching)
  return _internal_use_batching();
}
inline void PirParam_Config_messsage::set_use_batching(bool value) {
  _internal_set_use_batching(value);
  // @@protoc_insertion_point(field_set:pir_message.PirParam_Config_messsage.Use_batching)
}
inline bool PirParam_Config_messsage::_internal_use_batching() const {
  return _impl_.use_batching_;
}
inline void PirParam_Config_messsage::_internal_set_use_batching(bool value) {
  ;
  _impl_.use_batching_ = value;
}

// bool Use_recursive_mod_switching = 3;
inline void PirParam_Config_messsage::clear_use_recursive_mod_switching() {
  _impl_.use_recursive_mod_switching_ = false;
}
inline bool PirParam_Config_messsage::use_recursive_mod_switching() const {
  // @@protoc_insertion_point(field_get:pir_message.PirParam_Config_messsage.Use_recursive_mod_switching)
  return _internal_use_recursive_mod_switching();
}
inline void PirParam_Config_messsage::set_use_recursive_mod_switching(bool value) {
  _internal_set_use_recursive_mod_switching(value);
  // @@protoc_insertion_point(field_set:pir_message.PirParam_Config_messsage.Use_recursive_mod_switching)
}
inline bool PirParam_Config_messsage::_internal_use_recursive_mod_switching() const {
  return _impl_.use_recursive_mod_switching_;
}
inline void PirParam_Config_messsage::_internal_set_use_recursive_mod_switching(bool value) {
  ;
  _impl_.use_recursive_mod_switching_ = value;
}

// uint64 Num_of_items = 4;
inline void PirParam_Config_messsage::clear_num_of_items() {
  _impl_.num_of_items_ = ::uint64_t{0u};
}
inline ::uint64_t PirParam_Config_messsage::num_of_items() const {
  // @@protoc_insertion_point(field_get:pir_message.PirParam_Config_messsage.Num_of_items)
  return _internal_num_of_items();
}
inline void PirParam_Config_messsage::set_num_of_items(::uint64_t value) {
  _internal_set_num_of_items(value);
  // @@protoc_insertion_point(field_set:pir_message.PirParam_Config_messsage.Num_of_items)
}
inline ::uint64_t PirParam_Config_messsage::_internal_num_of_items() const {
  return _impl_.num_of_items_;
}
inline void PirParam_Config_messsage::_internal_set_num_of_items(::uint64_t value) {
  ;
  _impl_.num_of_items_ = value;
}

// uint64 Size_per_item = 5;
inline void PirParam_Config_messsage::clear_size_per_item() {
  _impl_.size_per_item_ = ::uint64_t{0u};
}
inline ::uint64_t PirParam_Config_messsage::size_per_item() const {
  // @@protoc_insertion_point(field_get:pir_message.PirParam_Config_messsage.Size_per_item)
  return _internal_size_per_item();
}
inline void PirParam_Config_messsage::set_size_per_item(::uint64_t value) {
  _internal_set_size_per_item(value);
  // @@protoc_insertion_point(field_set:pir_message.PirParam_Config_messsage.Size_per_item)
}
inline ::uint64_t PirParam_Config_messsage::_internal_size_per_item() const {
  return _impl_.size_per_item_;
}
inline void PirParam_Config_messsage::_internal_set_size_per_item(::uint64_t value) {
  ;
  _impl_.size_per_item_ = value;
}

// uint32 D = 6;
inline void PirParam_Config_messsage::clear_d() {
  _impl_.d_ = 0u;
}
inline ::uint32_t PirParam_Config_messsage::d() const {
  // @@protoc_insertion_point(field_get:pir_message.PirParam_Config_messsage.D)
  return _internal_d();
}
inline void PirParam_Config_messsage::set_d(::uint32_t value) {
  _internal_set_d(value);
  // @@protoc_insertion_point(field_set:pir_message.PirParam_Config_messsage.D)
}
inline ::uint32_t PirParam_Config_messsage::_internal_d() const {
  return _impl_.d_;
}
inline void PirParam_Config_messsage::_internal_set_d(::uint32_t value) {
  ;
  _impl_.d_ = value;
}

// bytes EPParams = 7;
inline void PirParam_Config_messsage::clear_epparams() {
  _impl_.epparams_.ClearToEmpty();
}
inline const std::string& PirParam_Config_messsage::epparams() const {
  // @@protoc_insertion_point(field_get:pir_message.PirParam_Config_messsage.EPParams)
  return _internal_epparams();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PirParam_Config_messsage::set_epparams(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.epparams_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pir_message.PirParam_Config_messsage.EPParams)
}
inline std::string* PirParam_Config_messsage::mutable_epparams() {
  std::string* _s = _internal_mutable_epparams();
  // @@protoc_insertion_point(field_mutable:pir_message.PirParam_Config_messsage.EPParams)
  return _s;
}
inline const std::string& PirParam_Config_messsage::_internal_epparams() const {
  return _impl_.epparams_.Get();
}
inline void PirParam_Config_messsage::_internal_set_epparams(const std::string& value) {
  ;


  _impl_.epparams_.Set(value, GetArenaForAllocation());
}
inline std::string* PirParam_Config_messsage::_internal_mutable_epparams() {
  ;
  return _impl_.epparams_.Mutable( GetArenaForAllocation());
}
inline std::string* PirParam_Config_messsage::release_epparams() {
  // @@protoc_insertion_point(field_release:pir_message.PirParam_Config_messsage.EPParams)
  return _impl_.epparams_.Release();
}
inline void PirParam_Config_messsage::set_allocated_epparams(std::string* value) {
  _impl_.epparams_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.epparams_.IsDefault()) {
          _impl_.epparams_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pir_message.PirParam_Config_messsage.EPParams)
}

// -------------------------------------------------------------------

// RequestData

// uint32 RequestId = 1;
inline void RequestData::clear_requestid() {
  _impl_.requestid_ = 0u;
}
inline ::uint32_t RequestData::requestid() const {
  // @@protoc_insertion_point(field_get:pir_message.RequestData.RequestId)
  return _internal_requestid();
}
inline void RequestData::set_requestid(::uint32_t value) {
  _internal_set_requestid(value);
  // @@protoc_insertion_point(field_set:pir_message.RequestData.RequestId)
}
inline ::uint32_t RequestData::_internal_requestid() const {
  return _impl_.requestid_;
}
inline void RequestData::_internal_set_requestid(::uint32_t value) {
  ;
  _impl_.requestid_ = value;
}

// uint32 ClientId = 2;
inline void RequestData::clear_clientid() {
  _impl_.clientid_ = 0u;
}
inline ::uint32_t RequestData::clientid() const {
  // @@protoc_insertion_point(field_get:pir_message.RequestData.ClientId)
  return _internal_clientid();
}
inline void RequestData::set_clientid(::uint32_t value) {
  _internal_set_clientid(value);
  // @@protoc_insertion_point(field_set:pir_message.RequestData.ClientId)
}
inline ::uint32_t RequestData::_internal_clientid() const {
  return _impl_.clientid_;
}
inline void RequestData::_internal_set_clientid(::uint32_t value) {
  ;
  _impl_.clientid_ = value;
}

// .pir_message.PirParam_Config_messsage PirConfig = 3;
inline bool RequestData::has_pirconfig() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.pirconfig_ != nullptr);
  return value;
}
inline void RequestData::clear_pirconfig() {
  if (_impl_.pirconfig_ != nullptr) _impl_.pirconfig_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::pir_message::PirParam_Config_messsage& RequestData::_internal_pirconfig() const {
  const ::pir_message::PirParam_Config_messsage* p = _impl_.pirconfig_;
  return p != nullptr ? *p : reinterpret_cast<const ::pir_message::PirParam_Config_messsage&>(
      ::pir_message::_PirParam_Config_messsage_default_instance_);
}
inline const ::pir_message::PirParam_Config_messsage& RequestData::pirconfig() const {
  // @@protoc_insertion_point(field_get:pir_message.RequestData.PirConfig)
  return _internal_pirconfig();
}
inline void RequestData::unsafe_arena_set_allocated_pirconfig(
    ::pir_message::PirParam_Config_messsage* pirconfig) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pirconfig_);
  }
  _impl_.pirconfig_ = pirconfig;
  if (pirconfig) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pir_message.RequestData.PirConfig)
}
inline ::pir_message::PirParam_Config_messsage* RequestData::release_pirconfig() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::pir_message::PirParam_Config_messsage* temp = _impl_.pirconfig_;
  _impl_.pirconfig_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pir_message::PirParam_Config_messsage* RequestData::unsafe_arena_release_pirconfig() {
  // @@protoc_insertion_point(field_release:pir_message.RequestData.PirConfig)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::pir_message::PirParam_Config_messsage* temp = _impl_.pirconfig_;
  _impl_.pirconfig_ = nullptr;
  return temp;
}
inline ::pir_message::PirParam_Config_messsage* RequestData::_internal_mutable_pirconfig() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.pirconfig_ == nullptr) {
    auto* p = CreateMaybeMessage<::pir_message::PirParam_Config_messsage>(GetArenaForAllocation());
    _impl_.pirconfig_ = p;
  }
  return _impl_.pirconfig_;
}
inline ::pir_message::PirParam_Config_messsage* RequestData::mutable_pirconfig() {
  ::pir_message::PirParam_Config_messsage* _msg = _internal_mutable_pirconfig();
  // @@protoc_insertion_point(field_mutable:pir_message.RequestData.PirConfig)
  return _msg;
}
inline void RequestData::set_allocated_pirconfig(::pir_message::PirParam_Config_messsage* pirconfig) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.pirconfig_;
  }
  if (pirconfig) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(pirconfig);
    if (message_arena != submessage_arena) {
      pirconfig = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pirconfig, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.pirconfig_ = pirconfig;
  // @@protoc_insertion_point(field_set_allocated:pir_message.RequestData.PirConfig)
}

// bytes Gkey = 4;
inline void RequestData::clear_gkey() {
  _impl_.gkey_.ClearToEmpty();
}
inline const std::string& RequestData::gkey() const {
  // @@protoc_insertion_point(field_get:pir_message.RequestData.Gkey)
  return _internal_gkey();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RequestData::set_gkey(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.gkey_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pir_message.RequestData.Gkey)
}
inline std::string* RequestData::mutable_gkey() {
  std::string* _s = _internal_mutable_gkey();
  // @@protoc_insertion_point(field_mutable:pir_message.RequestData.Gkey)
  return _s;
}
inline const std::string& RequestData::_internal_gkey() const {
  return _impl_.gkey_.Get();
}
inline void RequestData::_internal_set_gkey(const std::string& value) {
  ;


  _impl_.gkey_.Set(value, GetArenaForAllocation());
}
inline std::string* RequestData::_internal_mutable_gkey() {
  ;
  return _impl_.gkey_.Mutable( GetArenaForAllocation());
}
inline std::string* RequestData::release_gkey() {
  // @@protoc_insertion_point(field_release:pir_message.RequestData.Gkey)
  return _impl_.gkey_.Release();
}
inline void RequestData::set_allocated_gkey(std::string* value) {
  _impl_.gkey_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.gkey_.IsDefault()) {
          _impl_.gkey_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pir_message.RequestData.Gkey)
}

// bytes Query = 5;
inline void RequestData::clear_query() {
  _impl_.query_.ClearToEmpty();
}
inline const std::string& RequestData::query() const {
  // @@protoc_insertion_point(field_get:pir_message.RequestData.Query)
  return _internal_query();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RequestData::set_query(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.query_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pir_message.RequestData.Query)
}
inline std::string* RequestData::mutable_query() {
  std::string* _s = _internal_mutable_query();
  // @@protoc_insertion_point(field_mutable:pir_message.RequestData.Query)
  return _s;
}
inline const std::string& RequestData::_internal_query() const {
  return _impl_.query_.Get();
}
inline void RequestData::_internal_set_query(const std::string& value) {
  ;


  _impl_.query_.Set(value, GetArenaForAllocation());
}
inline std::string* RequestData::_internal_mutable_query() {
  ;
  return _impl_.query_.Mutable( GetArenaForAllocation());
}
inline std::string* RequestData::release_query() {
  // @@protoc_insertion_point(field_release:pir_message.RequestData.Query)
  return _impl_.query_.Release();
}
inline void RequestData::set_allocated_query(std::string* value) {
  _impl_.query_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.query_.IsDefault()) {
          _impl_.query_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pir_message.RequestData.Query)
}

// string DBName = 6;
inline void RequestData::clear_dbname() {
  _impl_.dbname_.ClearToEmpty();
}
inline const std::string& RequestData::dbname() const {
  // @@protoc_insertion_point(field_get:pir_message.RequestData.DBName)
  return _internal_dbname();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RequestData::set_dbname(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.dbname_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pir_message.RequestData.DBName)
}
inline std::string* RequestData::mutable_dbname() {
  std::string* _s = _internal_mutable_dbname();
  // @@protoc_insertion_point(field_mutable:pir_message.RequestData.DBName)
  return _s;
}
inline const std::string& RequestData::_internal_dbname() const {
  return _impl_.dbname_.Get();
}
inline void RequestData::_internal_set_dbname(const std::string& value) {
  ;


  _impl_.dbname_.Set(value, GetArenaForAllocation());
}
inline std::string* RequestData::_internal_mutable_dbname() {
  ;
  return _impl_.dbname_.Mutable( GetArenaForAllocation());
}
inline std::string* RequestData::release_dbname() {
  // @@protoc_insertion_point(field_release:pir_message.RequestData.DBName)
  return _impl_.dbname_.Release();
}
inline void RequestData::set_allocated_dbname(std::string* value) {
  _impl_.dbname_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.dbname_.IsDefault()) {
          _impl_.dbname_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pir_message.RequestData.DBName)
}

// -------------------------------------------------------------------

// ResponseData

// uint32 RequestId = 1;
inline void ResponseData::clear_requestid() {
  _impl_.requestid_ = 0u;
}
inline ::uint32_t ResponseData::requestid() const {
  // @@protoc_insertion_point(field_get:pir_message.ResponseData.RequestId)
  return _internal_requestid();
}
inline void ResponseData::set_requestid(::uint32_t value) {
  _internal_set_requestid(value);
  // @@protoc_insertion_point(field_set:pir_message.ResponseData.RequestId)
}
inline ::uint32_t ResponseData::_internal_requestid() const {
  return _impl_.requestid_;
}
inline void ResponseData::_internal_set_requestid(::uint32_t value) {
  ;
  _impl_.requestid_ = value;
}

// int32 Result = 2;
inline void ResponseData::clear_result() {
  _impl_.result_ = 0;
}
inline ::int32_t ResponseData::result() const {
  // @@protoc_insertion_point(field_get:pir_message.ResponseData.Result)
  return _internal_result();
}
inline void ResponseData::set_result(::int32_t value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:pir_message.ResponseData.Result)
}
inline ::int32_t ResponseData::_internal_result() const {
  return _impl_.result_;
}
inline void ResponseData::_internal_set_result(::int32_t value) {
  ;
  _impl_.result_ = value;
}

// string Msg = 3;
inline void ResponseData::clear_msg() {
  _impl_.msg_.ClearToEmpty();
}
inline const std::string& ResponseData::msg() const {
  // @@protoc_insertion_point(field_get:pir_message.ResponseData.Msg)
  return _internal_msg();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ResponseData::set_msg(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.msg_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pir_message.ResponseData.Msg)
}
inline std::string* ResponseData::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:pir_message.ResponseData.Msg)
  return _s;
}
inline const std::string& ResponseData::_internal_msg() const {
  return _impl_.msg_.Get();
}
inline void ResponseData::_internal_set_msg(const std::string& value) {
  ;


  _impl_.msg_.Set(value, GetArenaForAllocation());
}
inline std::string* ResponseData::_internal_mutable_msg() {
  ;
  return _impl_.msg_.Mutable( GetArenaForAllocation());
}
inline std::string* ResponseData::release_msg() {
  // @@protoc_insertion_point(field_release:pir_message.ResponseData.Msg)
  return _impl_.msg_.Release();
}
inline void ResponseData::set_allocated_msg(std::string* value) {
  _impl_.msg_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.msg_.IsDefault()) {
          _impl_.msg_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pir_message.ResponseData.Msg)
}

// bytes Data = 4;
inline void ResponseData::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& ResponseData::data() const {
  // @@protoc_insertion_point(field_get:pir_message.ResponseData.Data)
  return _internal_data();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ResponseData::set_data(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.data_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pir_message.ResponseData.Data)
}
inline std::string* ResponseData::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:pir_message.ResponseData.Data)
  return _s;
}
inline const std::string& ResponseData::_internal_data() const {
  return _impl_.data_.Get();
}
inline void ResponseData::_internal_set_data(const std::string& value) {
  ;


  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* ResponseData::_internal_mutable_data() {
  ;
  return _impl_.data_.Mutable( GetArenaForAllocation());
}
inline std::string* ResponseData::release_data() {
  // @@protoc_insertion_point(field_release:pir_message.ResponseData.Data)
  return _impl_.data_.Release();
}
inline void ResponseData::set_allocated_data(std::string* value) {
  _impl_.data_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.data_.IsDefault()) {
          _impl_.data_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pir_message.ResponseData.Data)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace pir_message


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_pirmessage_2eproto_2epb_2eh
